/*******ОБЯЗАТЕЛЬНО В КОДЕ на с++******************************************************************/
	#include "ros/ros.h"   // библиотека основных команд
        int main(int argc, char **argv){
                ros::init(argc, argv, "|имя ноды по умолчанию|");
                ros::NodeHandle n;   //объект для управления нодой
/**************************************************************************************************/
/*******Дополнительное*****************************************************************************/
	        ros::this_node::getName();   // для получения имени текущей ноды
/**************************************************************************************************/
/*******Код для Publisher**************************************************************************/
                ros::Publisher *pub* = *n*.advertise<'тип сообщения'>("|имя топика, в который отправляем|", 'буфер топика (1000)');   // создание типа для отправки сообщений в топик
                ros::Rate *loop_rate*('количесто сообщений в секунду');   // используют в циклах для задания частоты
                ///
                *pub*.publish('переменная');   // отправка сообщения
                *loop_rate*.sleep();   // ожидание для сохранении скорости
		ros::spinOnce();   // завершает все процессы
/**************************************************************************************************/
/*******Код для Client*****************************************************************************/
                ros::ServiceClient *client* = *n*.serviceClient<'тип сервиса'>("|сервис, в который отправляем|");
                'тип сервиса' *srv*;
		///
                *srv*.request.'ячейка сервиса';   // заполняем сервис для отправки, srv заранее созданный сервис
                ///
                *client*.call(*srv*);   // отправка сервиса, возращает true, если ответ пришёл
                srv.response.'ячейка ответа сервиса';   // получаем определённый ответ
/**************************************************************************************************/
/*******Код для Subscriber*************************************************************************/
                ros::Subscriber *sub* = *n*.subscribe("|топик, из которого читаем|", 'буфер топика(1000)', 'ф-ия обработчик полученного');
		ros::spin();   // позволяет считывать из топика каждый раз, когда туду что-то поступает
                //функция обработчик принимает в параметры константную ссылку на тип сообщения
/**************************************************************************************************/
/*******Код для Servis*****************************************************************************/
                ros::ServiceServer *service* = *n*.advertiseService("|сервис, который читаем|", 'ф-ия обработчик, возращиет bool')
/**************************************************************************************************/
/*******Использование классов для callback*********************************************************/
class *SubPub*{
        public:
                *SubPub*{
                        *pub* = *n*.advertise<''>("||", '');
                        *sub* = *n*.subscribe("||", '', &*SubPub*::*func*, this);
                }
                void *func*(''){
			//
                }
        private:
                 ros::NodeHandle *n*;
                 ros::Subscriber *sub*;
                 ros::Publisher *pub*;
}
/**************************************************************************************************/
/*******Код для Broadcaster************************************************************************/
#include <tf/tftransform_broadcaster.h>
///
        ros::Rate *r*(100); //Необходимо частота в 100 Гц для работы TF
        tf::TransforBroadcaster *broadcaster*;
        ///
        broadcaster.sendTransform(tf::StampedTransform(tf::Transform(tf::Quaternion('поворот объекта'), tf::Vector('координаты объекта')), ros::Time::now(), "|родительская СК|", "|дочерняя СК|"));
        *r*.sleep();
/**************************************************************************************************/
/*******Код для Listener***************************************************************************/
#include <tf/transform_listener.h>
#include <geometry_msgs/PointSramped.h>
///
        tf::TransformListener *listener*;
        geometry_msgs::PointStamped *start_point*; //Точка в изначальной СК
        *start_point*.header.frame_id = "|имя точки|";
        *start_point*.header.stamp = ros::Time(); //Для синхронизации
        ///Тут заполнения точки
        geometry_msgs::PointStamped *new_point*; //Точка в небходимой СК
        *listener*.transformPoint("|Необходимая СК|", 'start_point', 'new_point');
/**************************************************************************************************/
